// TCC Henrique Valiati - Monitoramento em redes de baixa e média tensão.
// ESP NÓ - CORRENTE

#include <Arduino.h>
#include <WiFi.h>
#include <esp_wifi.h>
#include <esp_now.h>
#include <Wire.h>
#include <TinyGPSPlus.h>
#include <MPU6050_light.h>
#include <esp_err.h>   

#define ID_DISPOSITIVO   2        
#define ID_REFERENCIA    1        

#define SSID_AP          "Poste"
#define SENHA_AP         "12345678"
#define CANAL_WIFI       6
#define CHAVE_ESPNOW     "CHAVE_PMK_16BITS"   

uint8_t MAC_MESTRE[] = { 0x6C, 0xC8, 0x40, 0x34, 0x4B, 0xC4 };

#define PINO_IR          34       
#define PINO_IS          35       
#define PINO_IT          32       
#define PINO_VBAT        33       

#define CAL_CORRENTE     100.0f   
#define FATOR_BAT        1.0f     

TinyGPSPlus gps;
MPU6050 mpu(Wire);

enum TipoNo : uint8_t { NO_TENSAO=1, NO_CORRENTE=2, NO_INCLINACAO=3 };

typedef struct __attribute__((packed)) {
  uint32_t id_dispositivo;
  uint8_t  tipo_no;
  uint32_t id_referencia;
  float    latitude, longitude;
  float    inclinacao_graus;
  char     status[10];
  float    tensao_bateria;
  int32_t  rssi;
  float    tensao_r, tensao_s, tensao_t;
  float    corrente_r, corrente_s, corrente_t;
  uint32_t contador;
  uint32_t tempo_segundos;
} PacoteNo;

PacoteNo pacote;
uint32_t contadorEnvios = 0;

void configurarADC(int pino){
  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);
  analogSetPinAttenuation(pino, ADC_11db);
  for(int i=0;i<30;i++) analogRead(pino);
}

float rmsADC(int pino, int N=2500){
  double soma = 0;
  for(int i=0;i<N;i++) soma += analogRead(pino);
  double media = soma / N;
  double sq = 0;
  for(int i=0;i<N;i++){
    double ac = analogRead(pino) - media;
    sq += ac * ac;
  }
  double rms_counts = sqrt(sq / N);
  return (rms_counts / 4095.0) * 3.30;
}

float lerBateria(){
  int bruto   = analogRead(PINO_VBAT);
  float v_adc = (bruto / 4095.0f) * 3.30f;
  return v_adc * FATOR_BAT;
}

void iniciarGPS(){
  Serial2.begin(9600, SERIAL_8N1, 16, 17);
}

bool lerGPS(float &lat, float &lon){
  while(Serial2.available()) gps.encode(Serial2.read());
  if(gps.location.isValid()){
    lat = gps.location.lat();
    lon = gps.location.lng();
    return true;
  }
  return false;
}

void iniciarMPU(){
  Wire.begin(21, 22);
  mpu.begin();
  delay(200);
  
  mpu.calcGyroOffsets();
}

void aoEnviar(const wifi_tx_info_t *info, esp_now_send_status_t status){
  (void)info;
  (void)status;
  
}

float lerInclinacaoGraus(){
  mpu.update();
  return mpu.getAngleX();
}

void setup(){
  Serial.begin(115200);
  delay(200);

  configurarADC(PINO_IR);
  configurarADC(PINO_IS);
  configurarADC(PINO_IT);
  configurarADC(PINO_VBAT);

  iniciarMPU();
  iniciarGPS();

  WiFi.mode(WIFI_STA);

  esp_wifi_set_promiscuous(true);
  esp_wifi_set_channel(CANAL_WIFI, WIFI_SECOND_CHAN_NONE);
  esp_wifi_set_promiscuous(false);

 
  if(esp_now_init() != ESP_OK){
    Serial.println("Falha ESP-NOW (esp_now_init)");
    ESP.restart();
  }

  esp_err_t e_pmk = esp_now_set_pmk((uint8_t*)CHAVE_ESPNOW);
  if(e_pmk != ESP_OK){
    Serial.printf("Aviso: esp_now_set_pmk falhou: %s\n", esp_err_to_name(e_pmk));
  }

  esp_now_register_send_cb(aoEnviar);

  esp_now_peer_info_t peer{};
  memcpy(peer.peer_addr, MAC_MESTRE, 6);
  peer.channel = CANAL_WIFI;
  peer.encrypt = false;

  esp_err_t e_peer = esp_now_add_peer(&peer);
  if(e_peer != ESP_OK){
    Serial.printf("Falha ao adicionar peer ESP-NOW: %s\n", esp_err_to_name(e_peer));
  } else {
    Serial.println("Peer (MESTRE) adicionado com sucesso.");
  }

  memset(&pacote, 0, sizeof(pacote));
  pacote.id_dispositivo = ID_DISPOSITIVO;
  pacote.tipo_no        = NO_CORRENTE;
  pacote.id_referencia  = ID_REFERENCIA;

  Serial.println("=== NO CORRENTE INICIADO ===");
}

void loop(){
  float ir_adc = rmsADC(PINO_IR);
  float is_adc = rmsADC(PINO_IS);
  float it_adc = rmsADC(PINO_IT);

  float ir = ir_adc * CAL_CORRENTE;
  float is = is_adc * CAL_CORRENTE;
  float it = it_adc * CAL_CORRENTE;

  float v_bat = lerBateria();

  float lat = 0, lon = 0;
  lerGPS(lat, lon);   

  float inc = lerInclinacaoGraus();

  pacote.latitude         = lat;
  pacote.longitude        = lon;
  pacote.inclinacao_graus = inc;
  pacote.tensao_bateria   = v_bat;

  pacote.tensao_r         = 0;
  pacote.tensao_s         = 0;
  pacote.tensao_t         = 0;

  pacote.corrente_r       = ir;
  pacote.corrente_s       = is;
  pacote.corrente_t       = it;

  pacote.contador         = ++contadorEnvios;
  pacote.tempo_segundos   = millis() / 1000;

  esp_err_t res = esp_now_send(MAC_MESTRE, (uint8_t*)&pacote, sizeof(pacote));

  Serial.printf("[CORRENTE] poste%02u -> ref %02u | R=%.2f S=%.2f T=%.2f A | inc=%.1f° | Vbat=%.2f | envio=%s (%s)\n",
                pacote.id_dispositivo, pacote.id_referencia,
                ir, is, it, inc, v_bat,
                res == ESP_OK ? "OK" : "ERRO",
                esp_err_to_name(res));

  delay(1000);
}
